import 'dart:ffi' as ffi;
import 'dart:typed_data';
import 'package:ffi/ffi.dart'; // For calloc
import 'package:hex/hex.dart';
import 'package:seed_repository/src/enums/enums.dart';
import 'package:seed_repository/src/enums/language.dart';
import 'package:seed_repository/src/enums/network.dart';
import 'package:seed_repository/src/enums/word_count.dart';
import 'seed_ffi.dart' as bindings; // The file generated by ffigen

class Mnemonic {
  static final _lib =
      ffi.DynamicLibrary.open('../../target/debug/libseed_ffi.dylib');
  static final _bindings = bindings.seed_ffi(_lib);

  Mnemonic({
    Language language = Language.english,
    WordCount wordCount = WordCount.words12,
  }) {
    final mnemonic =
        _bindings.new1(language.asFfiLanguage, wordCount.asFfiWordCount);
    final phrasePtr = mnemonic.ref.phrase as ffi.Pointer<Utf8>;
    phrase = phrasePtr.toDartString();
    _bindings.free_mnemonic(mnemonic);
  }

  Mnemonic.fromPhrase(this.phrase);

  late String phrase;

  // Derive a lightning seed
  Uint8List deriveLightningSeed(Network network, {int index = 535}) {
    // Allocate a pointer to the index
    ffi.Pointer<ffi.Uint32> indexPtr = calloc<ffi.Uint32>();
    indexPtr.value = index;

    // Get the Rust mnemonic pointer to derive the seed
    final phrasePtr = phrase.toNativeUtf8();
    final mnemonicPtr =
        _bindings.from_phrase(phrasePtr as ffi.Pointer<ffi.Char>);

    // Derive the seed
    final seedHexPtr = _bindings.derive_lightning_seed(
      mnemonicPtr,
      network.asFfiNetwork,
      indexPtr,
    );
    final seedHex = (seedHexPtr as ffi.Pointer<Utf8>).toDartString();

    // Convert the seed to bytes
    final seedBytes = HEX.decode(seedHex);
    if (seedBytes.length < 32) {
      throw Exception("Invalid seed length");
    }

    // Free the allocated memory
    calloc.free(indexPtr);
    _bindings.free_mnemonic(mnemonicPtr);
    calloc.free(seedHexPtr);

    // Return it as a Uint8List of 32 bytes
    return Uint8List.fromList(seedBytes.sublist(0, 32));
  }
}
